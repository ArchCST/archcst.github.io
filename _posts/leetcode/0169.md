title: Java x Leetcode [Q:0169]
date: 2020-03-13
updated: 
comments: true
tags:
  - learn
  - leetcode
layout: post
---
{% cq %}
<span style="font-variant: small-caps;">question</span>
AFK?
多数元素
{% endcq %}
<!--more-->

# AFK?
今天是刷题的第二十天。这二十天虽然刷的都是简单难度的题目，但也从中瞥见了一丝算法的门槛，比如数据解构，比如动态规划、KMP 等。
其实继续这么做简单难度的题目对我来说意义并不大。不是说题目简单，而是我做得没有章法。我的解很多都是一个自然而然的思路，看了官方或者大神的解之后才发现一道题可以有这么多解法。
这其实只是一直在不断地在练习自己已有的知识储备，而难以触碰到算法的本质。
昨所以我决定，要暂离一段时间。天京东了《算法4》，准备把每天做题的这一个小时拿来啃书。所以今天的这一题结束后，就要过一段时间了。
I'll be back.

# 题目
**编号**：0169
**链接**：[力扣](https://leetcode-cn.com/problems/majority-element/)
**题目**：多数元素
**简述**：
 * 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
 * 你可以假设数组是非空的，并且给定的数组总是存在多数元素。

# 题解(Java)
```java
public class Q0169 {
    private static int majorityElement(int[] nums) {
        if (nums.length == 1) return nums[0];
        int n = nums.length / 2;
        HashMap<Integer, Integer> map = new HashMap<>(); // 每个数组中存在的数为 Key，他们的个数为 value
        for (int num : nums) {
            if(map.containsKey(num)) {
                if (map.get(num) == n) {
                    // 当一个数已经有了长度的一半 +1 个，就可以直接返回了，因为其他数最多也只能占另外一半
                    return num;
                }
                map.put(num, map.get(num)+1);
            } else {
                map.put(num, 1);
            }
        }
        return 0; // 题设不会出现，随便乱设置
    }
    public static void main(String[] args) {
        System.out.println(majorityElement(new int[]{-1})); // -1
        System.out.println(majorityElement(new int[]{3,2,3})); // 3
        System.out.println(majorityElement(new int[]{2,2,1,1,1,2,2})); // 2
    }
}
```