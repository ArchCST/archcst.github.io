title: Java x Leetcode [Q:0038]
date: 2020-03-05
updated: 
comments: true
tags:
  - learn
  - leetcode
layout: post
---
{% cq %}
<span style="font-variant: small-caps;">question</span>
外观数列
{% endcq %}
<!--more-->

# 题目
**编号**：0038
**链接**：[力扣](https://leetcode-cn.com/problems/count-and-say/)
**题目**：外观数列
**简述**：
「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：
```
1.     1
2.     11
3.     21
4.     1211
5.     111221
```
`1` 被读作  "one 1"  ("一个一") , 即 11。
`11` 被读作 "two 1s" ("两个一"）, 即 21。
`21` 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。

给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。

注意：整数序列中的每一项将表示为一个字符串。
# 题解(Java)
```java
public class Q0038 {
    private static String countAndSay(int n) {
        StringBuilder osb = new StringBuilder("1"); // 上一行的字符串（旧字符串）

        // 遍历 n - 1 次，因为基数是从 1 开始的
        for (int i = 0; i < n-1; i++) {
            char c = osb.charAt(0); // 当前字符，初始化为旧字符串的第一位
            StringBuilder nsb = new StringBuilder(); // 即将生成的新字符串
            int count = 1; // 记录当前字符的重复次数

            // 遍历旧字符串，第一位一定匹配所以 count 初始为 1，并从第二位开始遍历
            for (int j = 1; j < osb.length(); j++) {
                if(osb.charAt(j) == c){ // 匹配则只对计数加 1
                    count++;
                } else {
                    // 如果遇到不相同的字符，把计数 count 和字符 c 添加到新字符串后面
                    nsb.append(count).append(c);
                    count = 1; // count 重设为 1
                    c = osb.charAt(j); // 更新当前字符
                }
            }

            // 遍历完旧字符串后需要把最后一次的计数和字符添加进去
            // 再把新字符串赋值给旧字符串进行下一次遍历
            osb = nsb.append(count).append(c);
        }
        return osb.toString();
    }

    public static void main(String[] args) {
        for (int i = 1; i < 10; i++) {
            System.out.println(i + ": " + countAndSay(i));
        }
    }
}
```