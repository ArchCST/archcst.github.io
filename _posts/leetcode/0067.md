title: Java x Leetcode [Q:0067]
date: 2020-03-09
updated: 
comments: true
tags:
  - learn
  - leetcode
layout: post
---
{% cq %}
<span style="font-variant: small-caps;">question</span>
二进制求和
{% endcq %}
<!--more-->

# 题目
**编号**：0067
**链接**：[力扣](https://leetcode-cn.com/problems/add-binary/)
**题目**：二进制求和
**简述**：
 * 给定两个二进制字符串，返回他们的和（用二进制表示）。
 * 输入为非空字符串且只包含数字 1 和 0。

# 题解(Java)
```java
public class Q0067 {
    private static String addBinary(String a, String b) {
        // 把短的字符串前面填充0，补成和长字符串一样
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < Math.abs(a.length() - b.length()); i++) {
            sb.append(0);
        }
        if (a.length() < b.length()) {
            a = sb.toString() + a;
        } else {
            b = sb.toString() + b;
        }

        // 进位
        int carry = 0;

        sb = new StringBuilder();

        for (int i = a.length() - 1; i >= 0; i--) {

            int sum = a.charAt(i) + b.charAt(i) - 2 * '0' + carry; // 计算两个字符串当前位相加再加上进位的值
            sb.append(sum % 2); // 对2取余，并附加到结果字符串的尾部，循环完成后翻转字符串
            carry = sum / 2; // 计算进位的量
        }

        // 循环完成后 carry 不为零，说明需要进位
        sb.append(carry == 1 ? carry : "");
        return sb.reverse().toString();
    }

    // 力扣更优解
    // https://leetcode-cn.com/problems/add-binary/solution/hua-jie-suan-fa-67-er-jin-zhi-qiu-he-by-guanpengch/
    private static String addBinary_LHHS(String a, String b) {
        StringBuilder ans = new StringBuilder(); // 返回值
        int carry = 0;
        for (int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j--) {
            carry += i >= 0 ? a.charAt(i) - '0' : 0;
            carry += j >= 0 ? b.charAt(j) - '0' : 0;

            ans.append(carry % 2);
            carry /= 2;
        }
        ans.append(carry == 1 ? carry : "");
        return ans.reverse().toString();
    }

    public static void main(String[] args) {
        System.out.println(addBinary("11", "1")); // "100"
        System.out.println(addBinary("1010", "1011")); // "10101"
        System.out.println(addBinary("1", "111")); // "10101"
    }
}
```

# 更好的解法
这个解[By 灵魂画手](https://leetcode-cn.com/problems/add-binary/solution/hua-jie-suan-fa-67-er-jin-zhi-qiu-he-by-guanpengch/)核心思路有两个：
1. 一个 for 里面同时循环两个字符串的索引
2. 用 append 往尾巴上添加字符，最后再 reverse，这样不需要频繁的移动字符串数组

```java
private static String addBinary_LHHS(String a, String b) {
    StringBuilder ans = new StringBuilder(); // 返回值
    int carry = 0;
    // 同时循环两个字符串的索引
    for (int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j--) {
        // 分别判断两个索引是否越界，没越界就加上
        carry += i >= 0 ? a.charAt(i) - '0' : 0;
        carry += j >= 0 ? b.charAt(j) - '0' : 0;
        
        ans.append(carry % 2); // 末尾添加当前位的结果
        carry /= 2; // 计算进位
    }
    ans.append(carry == 1 ? carry : "");
    return ans.reverse().toString(); // 返回 reverse
}
```